#PURPOSE: THIS PROGRAM CONVERTS AN INPUT FILE
#	  TO AN OUTPUT FILE WITH ALL LETTERS 
#	  CONVERTED TO UPPERCASE.
#
#PROCESSING: 1) OPEN THE INPUT FILE
#	     2) OPEN THE OUTPUT FILE
#	     3) WHILE WE'RE NOT AT THE END OF THE INPUT FILE
#		A) READ PART OF FILE INTO OUR MEMORY BUFFER
#		B) GO THROUGH EACH BYTE OF MEMORY
#			IF THE BYTE IS LOWERCASE LETTER,
#			CONVERT IT TO UPPERCASE
#		C) WRITE THE MEMORY BUFFER TO OUTPUT FILE

.SECTION .DATA

########CONSTANTS########

#SYSTEM CALL NUMBERS
.EQU SYS_OPEN, 5
.EQU SYS_WRITE, 4
.EQU SYS_READ, 3
.EQU SYS_CLOSE, 6
.EQU SYS_EXIT, 1

#OPTIONS FOR OPEN
.EQU O_RDONLY, 0
.EQU O_CREAT_WRONLY_TRUNC, 03101

#STANDARD FILE DESCRIPTORS
.EQU STDIN, 0
.EQU STDOUT, 1
.EQU STDERR, 2

#SYSTEM CALL INTERRUP
.EQU LINUX_SYSCALL, 0X80

.EQU END_OF_FILE, 0		#RETURN VALUE OF READ WHEN END OF FILE
.EQU NUMBER_ARGUMENTS, 2


.SECTION .BSS
#BUFFER - DATA FROM INPUF FILE LOADED INTO, 
#	  CONVERTED TO UPPERCASE AND WRITTEN
#	  TO OUTPUT FILE
.EQU BUFFER_SIZE, 500
.LCOMM BUFFER_DATA, BUFFER_SIZE	#CREATES BUFFER CALLED BUFFER_DATA
				#WITH SIZE OF 500 BYTES.


.SECTION .TEXT

#STACK POSITIONS
.EQU ST_SIZE_RESERVE, 8
.EQU ST_FD_IN, -4
.EQU ST_FD_OUT, -8
.EQU ST_ARGC, 0			#NUMBER OF ARGUMENTS
.EQU ST_ARGV_0, 4		#NAME OF PROGRAM
.EQU ST_ARGV_1, 8		#INPUT FILE NAME
.EQU ST_ARGV_2, 12		#OUTPUT FILE NAME

.GLOBL _START
_START:
####INITIALIZE PROGRAM#####
#SAVE STACK POINTER
MOVL %ESP, %EBP
# ALLOCATE SPACE FOR FILE DESCRIPTORS ON THE STACK
SUBL $ST_SIZE_RESERVE, %ESP	#2 WORDS

OPEN_FILES:
OPEN_FD_IN:			#OPEN INPUT FILE
MOVL $SYS_OPEN, %EAX		#MOVL 5 TO %EAX
MOVL ST_ARGV_1(%EBP), %EBX	#OUTPUT FILENAME INT %EBX
MOVL $O_RDONLY, %ECX		#SET FLAGS
MOVL $0666, %EDX		#MODE FOR NEW FILE
INT $LINUX_SYSCALL		#CALL LINUX

STORE_FD_IN:
MOVL %EAX, ST_FD_IN(%EBP)	#STORE FILE DESCRIPTOR


OPEN_FD_OUT:
MOVL $SYS_OPEN, %EAX
MOVL ST_ARGV_2(%EBP), %EBX
MOVL $O_CREAT_WRONLY_TRUNC, %ECX
MOVL $0666, %EDX
INT $LINUX_SYSCALL

STORE_FD_OUT:
MOVL %EAX, ST_FD_OUT(%EBP)	#STORE FILE DESCRIPTOR

READ_LOOP_BEGIN:
MOVL $SYS_READ, %EAX		#READ IN A BLOCK FROM INPUT FILE
				#MOVL 3 %EAX
MOVL ST_FD_IN(%EBP), %EBX	#GET INPUT FILE DESCRIPTOR
MOVL $BUFFER_DATA, %ECX		#THE LOCATION TO READ INTO
MOVL $BUFFER_SIZE, %EDX		#THE SIZE OF THE BUFFER
INT $LINUX_SYSCALL		#SIZE OF BUFFER READ IS RETURNED TO %EAX

#EXIT IF WE HAVE REACHED THE END
CMPL $END_OF_FILE, %EAX		#CHECK FOR THE END OF FILE MARKER
				#%EAX SHOULD BE 0
JLE END_LOOP			#IF FOUND OR ON ERROR, GO TO END
				#FOUND = EQUAL
				#ERROR = NEGATIVE NUMBERS

CONTINUE_READ_LOOP:
#CONVERT THE BLOCK TO UPPERCASE
PUSHL $BUFFER_DATA		#STORE LOCATION OF BUFFER
PUSHL %EAX			#STORE SIZE OF BUFFER
CALL CONVERT_TO_UPPER		#OUR FUNCTION THAT CONVERTS TO UPPERCASE
POPL %EAX			#GET THE SIZE BACK
ADDL $4, %ESP			#RESTORE STACK POINTER

#WRITE THE BLOCK OUT TO THE OUTPUT FILE
MOVL %EAX, %EDX			#BUFFER SIZE
MOVL $SYS_WRITE, %EAX		#SET %EAX TO 4
MOVL ST_FD_OUT(%EBP), %EBX	#THE FILEDESCRIPTOR OF THE OUTPUT FILE
MOVL $BUFFER_DATA, %ECX		#LOCATION OF THE BUFFER
INT $LINUX_SYSCALL		#CALL KERNEL

#CONTINUE THE LOOP
JMP READ_LOOP_BEGIN


END_LOOP:
#CLOSE THE FILES
MOVL $SYS_CLOSE, %EAX
MOVL ST_FD_OUT(%EBP), %EBX	#FILE DESCRIPTOR OUTPUT FILE
INT $LINUX_SYSCALL

MOVL $SYS_CLOSE, %EAX		#WE DO IT AGAIN SINCE %EAX COULD BE
				#MODIFIED BY OUR SYSCALL
MOVL ST_FD_IN(%EBP), %EBX	#FILE DESCIPTOR INPUT FILE
INT $LINUX_SYSCALL

#EXIT
MOVL $SYS_EXIT, %EAX		#SET %EAX TO 1
MOVL $0, %EBX			#RETURN 0 AS SUCCESS VALUE
INT $LINUX_SYSCALL



#PURPOSE: THIS FUNCTION ACTUALLY DOES THE CONVERSION 
#	  TO UPPERCASE FOR A BLOCK
#
#INPUT:	  FIRST PARAMETER IS THE LOCATION FO THE BLOCK OF
#	  MEMORY TO CONVERT
#	  THE SECOND PARAMETER IS THE LENGTH OF THAT BUFFER
#
#OUTPUT:  THIS FUNCTION OVERWRITES THE CURRENT BUFFER
#	  WITHT THE UPPER-CASIFIED VERSION
#
#VARIABLES:
#	  %EAX - BEGINNING OF BUFFER
#	  %EBX - LENGTH OF BUFFER
#	  %EDI - CURRENT BUFFER OFFSET
#	  %CL - CURRENT BYTE BEING EXAMINED (FIRST PART OF %ECX)

#CONSTANTS
.EQU LOWERCASE_A, 'A'		#LOWER BOUNDARY OF OUR SEARCH
.EQU LOWERCASE_Z, 'Z'		#UPPER BOUNDARY OF OUR SEARCH
.EQU UPPER_CONVERSION, 'A' - 'A'#CONVERSION BETWEEN UPPER
				#AND LOWER CASE

#STACK STUFF
.EQU ST_BUFFER_LEN, 8		#LENGTH OF BUFFER
.EQU ST_BUFFER, 12		#ACTUAL BUFFER

CONVERT_TO_UPPER:
PUSHL %EBP
MOVL %ESP, %EBP

#SET UP VARIABLES
MOVL ST_BUFFER(%EBP), %EAX
MOVL ST_BUFFER_LEN(%EBP), %EBX
MOVL $0, %EDI

CMPL $0, %EBX			#CHECK IF THE BUFFER WAS ZERO
JE END_CONVERT_LOOP		#IF SO, JUST LEAVE

CONVERT_LOOP:
MOVB (%EAX,%EDI,1), %CL		#GET THE BYTE AND MOVE IT INTO %CLI
				#BYTE = (BEGINNING OF BUFFER,
				#	 BUFFER OFFSET - HOW FOR ARE WE
				#	 WORD LENGHT 1
				#%CL LOWER END %EXC

CMPB $LOWERCASE_A, %CL		#CHECK IF THE BYTE IS BETWEEN A
JL NEXT_BYTE			#AND Z
CMPB $LOWERCASE_Z, %CL		#IF NOT, GO THE NEXT BYTE
JG NEXT_BYTE

ADDB $UPPER_CONVERSION, %CL	#OTHERWISE, CONVERT TO UPPERCASE
MOVB %CL, (%EAX,%EDI,1)		#STORE IT BACK INTO BUFFER

NEXT_BYTE:
INCL %EDI			#INCREMENT BUFFER OFFSET WITH 1
CMPL %EDI, %EBX			#CONTINUE UNTIL WE HAVE REACHED
				#THE END
JNE CONVERT_LOOP


END_CONVERT_LOOP:
MOVL %EBP, %ESP			#NO RETURN VALUE, JUST LEAVE
POPL %EBP
RET
